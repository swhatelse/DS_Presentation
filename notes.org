* DONE Introduction [2/2]
*** DONE Why Raft?
- Paxos:
  - Most of consenus implementations based on it
  - But difficult to understand \to difficult to set up
- Goal:
  - Design *understandable* consensus algorithm
*** DONE Caracteristics
     - Applied technics to improve understandability:
       - Decomposition:
         - Leader election
         - Log replication
         - Safety
       - State space reduction:
         - Reduce nonderterminism
         - The way the server are consistents
     - Use of novel features:
       - Strong leader
       - Leader election
       - Membership changes
* TODO Replicated state machines
  - Implemented using replicated log
  - Consistency of replicated log ensure by consensus algo
  - General principle of consensus algo (like we saw in course):
    - Receive request of client
    - Aggreed with other server on the order
    - Append it to its log
    - Process the log (each process)
    - Send result to client
  # The two last points are missing
* DONE The problem with Paxos
  - Advantages:
    - Capabilities
      - reaching agreement on a single decision
      - combination of instances \to facilitate series of decision (multi-Paxos) 
      - Membership changes
    - Ensure:
      - safety
      - liveness
    - Has been proven
  - Drawbacks:
    - Very difficult to understand \to took one year understand completly, 
      only few persons understand it 
    - Due to its Single-decree fundation \to should be decomposed
    - lack of details, different interpretation
    - architecture of PaXos not suited for most practical systems
    - Difficulties to implement \to real implemention different from Paxos
      \to build on top unproven system.
* DONE Designing for understandability
  - Choices made around understandabilty
  - Easier to understand the algo, develop intuitions
	\to easier to extend to real-world implementations
  - 2 technics:
    - Problem decomposition
      - election leader, log replication, safety, membership
        changes \to independants
    - Reduce state space
      - eliminates nondeterminism where needed
* TODO Raft [5/6]
** DONE Basics
   - 3 states: 
     - leader: handles requests 
     - follower: responde to the leader 
     - candidate: used to elect a new leader
   - Time divided in terms.
	 - Term starts with on election
	 - Used as logical clock
** DONE Leader election
   - Leader send heartbeat to followers
   - Followers have a timeout, if they don't receive an
	 heartbeat from the leader before the timeout \to candidate
	 state.
   - Candidate trigger an election 
     - Increment term 
	 - Vote for him self
     - send RPC Vote, first come first serve
	 - Win if majority votes.
	 - other server send a vote, they reject the vote request if the term 
       number is less or if they alreadt have responded
	 - Stay in candidate state until:
	   - win the election
		 - Send heartbeat to establish its authority
	   - another win
	     - received heartbeat from leader at least same term
	   - timeout
** DONE Log replication
   - Clients send commands to the leader
   - Entry commited when replicated in majority
   - Leader check its logs are consistent with others:
	 - send the previous index + term
	 - look for the moment when start diverging \to remove
	   all logs after this point and send its log after this point.
	   - when not matching decrements nextIndex until it finds a
		 matching log.
** TODO Safety
** DONE Follower and candidate crashes
   - Leader keeps sending RPC until the candidature/follower recovers.
   - RPC are idempotents.
** DONE Timing and avaibility
   - Import for the correctness of election mechanism.
   - BroadcastTime << electionTimeout << MTBF (mean time before failure for a single node)
	 - broadcastTime << electionTime \to leader can send reliably timeout
	 - electionTime << MTBF \to the system can make progress without trigger unnecessary 
       election.
   - Only electionTimeout can be tuned and must be choosen according to BCtime and MTBF
* TODO Cluster membership changes
  - View change
  - Possible to have two leaders elected in the same term \to splitted
	majority.
  - atomic switch of all the server impossible \to two-phase approach \to joint consensus
  - when joining server may not have any logs:
    - pre-join \to non-voting server \to can retrieve the log without interferring (impossibility
	to commit log)
  - leader removed (not anymore in the config)
	- become follower after C_new committed
  - Interferences of removed servers
	- Will not receive heartbeat \to trigger election with new term
	- Current leader \to follower
	- removed server timeout and repeat again
* TODO Implementation and evalution [2/3]
** DONE Understandability
   - Took student from Stanford University and U.C. Berkeley
   - Video lecture on Paxos and Raft
   - Quizzes \to Raft has better notes
** TODO Correctness
   - Cf. safety proof. 
   - Relies on invariant that have not been checked.
** DONE Perfomances
   - Replication use minimal number of message 
   - 2 concern 
     - Time of convergence of the election
	   What takes time is the split votes.
	   To reduce chances of split vote \to use of randomness
     - Down time
	   function of the election timeout. The smaller it is the smaller the down time.
	   But can not be to small \to unnecessary leader changes
   - Remark:
	 Number of process used is missing. Would be interesting to know if the election process 
     is really scallable. With lots of nodes more likely to have splitted votes \to the 
     process could repeat a during a log time. 
     Maybe increase election timeout \to increase downtime.
